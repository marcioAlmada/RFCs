====== PHP RFC: Callable Types ======
  * Version: 0.0
  * Date: 2015-08-27
  * Authors: Nikita Nefedov <inefedor@gmail.com>, MÃ¡rcio Almada <marcio3w@gmail.com>
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/callable-types

===== Introduction =====

This RFC proposes an evolution of the **callable** type, scoped to argument lists. This should allow more detailed declarations
**callable** "typehints" - including their **arity**, **arguments** types and **return type**.

Here is one basic comparison between a simple **callable** and a **callable prototype** declaration:

<code php>
// Before
/**
 * @param  callable(int, int):int $reducer
 */
function reduce(int $a, int $b, callable $reducer) : int {
  return $reducer($a, $b);
}

// call with bad callback
reduce(1, 2, function($a, $b, $c) {
  return $a + $b + $c;
});
// >>>
// Warning: Missing argument 3 for {closure}(), called in ...
// Notice: Undefined variable: c in ...
// TypeError: Return value of reduce() must be of the type integer, string returned in ...
</code>

<code php>
// After
function reduce(int $a, int $b, callable(int, int):int $reducer) : int {
  return $reducer($a, $b);
}

// call with bad callback
reduce(1, 2, function($a, $b, $c) {
  return $a + $b + $c;
});
// >>>
// TypeError: Argument 3 passed to reduce() must be callable(int, int):int, callable($a, $b, $c) given...
</code>

This concept is also present in other languages, commonly referred as **function prototypes** or **function interfaces**.

> NOTE: This RFC is **not** related to "generics".

===== Proposal =====

==== Why? ====

Callable types might be particularly useful to write more robust callback based code (functional or not). This includes:

=== Better Error Messages ===

<code php>
// before
</code>

<code php>
// after
</code>

=== Safety Before Side Effects ===

While callable types can offer more debug friendlier messages, there are other factor that could favor earlier
failures approach. In some cases, a callback might create or precede a side effect.

Specifying a more constrained callable type allows a given routine to fail before an operation that creates side effect:

<code php>
// example of a rejected callable that shows early failure
</code>

This certainly can be achieved without callable types: perhaps using reflection or manual type checking of return values
but certainly callable types can make this kind of situation less tedious and therefore more productive.

=== Self Documented Code ===

It's common to see callback based libraries doing their best to declare the callable signatures on docblocks, hoping that
the consumers will be able to figure out what to pass around:

<code php>
// before
</code>

With callable types, the codebase simply becomes much closer to "self documented", so this is not contrived to runtime checks
that will assist the user land.

<code php>
// after
</code>

==== Why Not? ====

One might say that function prototypes "does not fit the PHP loosely typed model". This might be true to part of the
community, at some extent, but it's possible to affirm that PHP already supports function prototypes - but their potential is
currently 'confined' inside interfaces and abstract classes definitions:

<code php>
interface FooInterface {
    function foo(A $a, B $b): C; // this is a function prototype, part of an interface
}

abstract class Foo {
    function bar(A $a, B $b): C; // this is a function prototype too
}
</code>

==== Arity ====

=> Add case by case + examples with less required args, more required args, optional args...

==== Variance and Signature Validation ====

=> Add rich examples here

==== Syntax Choices ====

The syntax is similar to the one already used to declare prototypes on interfaces and abstract classes member, and should
look meaningful to anyone who already knows how to declare a PHP interface.

There's only one major distinction. While declaring a callable type, it's possible to omit the argument names from argument lists
when a given argument has type information:

<code php>
// the declarations below are synonyms:

function foo(callable(string $string_a, string $string_b):string $callback) {}

function foo(callable(string, string):string $callback) {}
</code>

The argument names can be valuable, but there are cases they represent unnecessary verbosity. Hence why they can be omitted.

=> research common syntax used inside docblocks to describe callables, find examples within OSS projects to use as a reference

===== Backward Incompatible Changes =====

The proposal has no BC breaks.

===== Proposed PHP Version(s) =====

The proposal targets PHP 7.1.

===== RFC Impact =====

==== Performance ====

The addition of more specific callable types definitions will not offer any penalty to the simpler `callable` already in use.

This is a synthetic benchmark between a function using a "simple callable" and a function using a "complex callable" on it's argument list:

<code>
// benchmark code
</code>>

=> The loss will probably be negligible so we'll need to count CPU instructions to show the difference.

==== To Opcache ====

=> ...

===== Open Issues =====

=> interaction with union types RFC

=> interaction with arrow functions RFC

===== Unaffected PHP Functionality =====

The current `callable` implementation should not have any of it's behaviors altered and will still be available.
The RFC merely augments how callable can be declared.

===== Future Scope =====

=> callable type reuse?

=> talk about the intention to add a reflection api if the RFC gets accepted

===== Proposed Voting Choices =====

=> ...

===== Patches and Tests =====

Links to any external patches and tests go here.

If there is no patch, make it clear who will create a patch, or whether a volunteer to help with implementation is needed.

Make it clear if the patch is intended to be the final patch, or is just a prototype.

===== Implementation =====

=> ...

===== References =====

=> ...

===== Rejected Features =====

=> ...
